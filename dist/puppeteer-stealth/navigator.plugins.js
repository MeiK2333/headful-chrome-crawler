"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
function navigatorPlugins(page) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, page.evaluateOnNewDocument("\n    function mockPluginsAndMimeTypes() {\n        /* global MimeType MimeTypeArray PluginArray */\n    \n        // Disguise custom functions as being native\n        const makeFnsNative = (fns = []) => {\n            const oldCall = Function.prototype.call\n            function call() {\n                return oldCall.apply(this, arguments)\n            }\n            // eslint-disable-next-line\n            Function.prototype.call = call\n    \n            const nativeToStringFunctionString = Error.toString().replace(\n                /Error/g,\n                'toString'\n            )\n            const oldToString = Function.prototype.toString\n    \n            function functionToString() {\n                for (const fn of fns) {\n                    if (this === fn.ref) {\n                        return `function ${fn.name}() { [native code] }`\n                    }\n                }\n    \n                if (this === functionToString) {\n                    return nativeToStringFunctionString\n                }\n                return oldCall.call(oldToString, this)\n            }\n            // eslint-disable-next-line\n            Function.prototype.toString = functionToString\n        }\n    \n        const mockedFns = []\n    \n        const fakeData = {\n            mimeTypes: [\n                {\n                    type: 'application/pdf',\n                    suffixes: 'pdf',\n                    description: '',\n                    __pluginName: 'Chrome PDF Viewer'\n                },\n                {\n                    type: 'application/x-google-chrome-pdf',\n                    suffixes: 'pdf',\n                    description: 'Portable Document Format',\n                    __pluginName: 'Chrome PDF Plugin'\n                },\n                {\n                    type: 'application/x-nacl',\n                    suffixes: '',\n                    description: 'Native Client Executable',\n                    enabledPlugin: Plugin,\n                    __pluginName: 'Native Client'\n                },\n                {\n                    type: 'application/x-pnacl',\n                    suffixes: '',\n                    description: 'Portable Native Client Executable',\n                    __pluginName: 'Native Client'\n                }\n            ],\n            plugins: [\n                {\n                    name: 'Chrome PDF Plugin',\n                    filename: 'internal-pdf-viewer',\n                    description: 'Portable Document Format'\n                },\n                {\n                    name: 'Chrome PDF Viewer',\n                    filename: 'mhjfbmdgcfjbbpaeojofohoefgiehjai',\n                    description: ''\n                },\n                {\n                    name: 'Native Client',\n                    filename: 'internal-nacl-plugin',\n                    description: ''\n                }\n            ],\n            fns: {\n                namedItem: instanceName => {\n                    // Returns the Plugin/MimeType with the specified name.\n                    const fn = function (name) {\n                        if (!arguments.length) {\n                            throw new TypeError(\n                                `Failed to execute 'namedItem' on '${instanceName}': 1 argument required, but only 0 present.`\n                            )\n                        }\n                        return this[name] || null\n                    }\n                    mockedFns.push({ ref: fn, name: 'namedItem' })\n                    return fn\n                },\n                item: instanceName => {\n                    // Returns the Plugin/MimeType at the specified index into the array.\n                    const fn = function (index) {\n                        if (!arguments.length) {\n                            throw new TypeError(\n                                `Failed to execute 'namedItem' on '${instanceName}': 1 argument required, but only 0 present.`\n                            )\n                        }\n                        return this[index] || null\n                    }\n                    mockedFns.push({ ref: fn, name: 'item' })\n                    return fn\n                },\n                refresh: instanceName => {\n                    // Refreshes all plugins on the current page, optionally reloading documents.\n                    const fn = function () {\n                        return undefined\n                    }\n                    mockedFns.push({ ref: fn, name: 'refresh' })\n                    return fn\n                }\n            }\n        }\n        // Poor mans _.pluck\n        const getSubset = (keys, obj) =>\n            keys.reduce((a, c) => ({ ...a, [c]: obj[c] }), {})\n    \n        function generateMimeTypeArray() {\n            const arr = fakeData.mimeTypes\n                .map(obj => getSubset(['type', 'suffixes', 'description'], obj))\n                .map(obj => Object.setPrototypeOf(obj, MimeType.prototype))\n            arr.forEach(obj => {\n                arr[obj.type] = obj\n            })\n    \n            // Mock functions\n            arr.namedItem = fakeData.fns.namedItem('MimeTypeArray')\n            arr.item = fakeData.fns.item('MimeTypeArray')\n    \n            return Object.setPrototypeOf(arr, MimeTypeArray.prototype)\n        }\n    \n        const mimeTypeArray = generateMimeTypeArray()\n        Object.defineProperty(navigator, 'mimeTypes', {\n            get: () => mimeTypeArray\n        })\n    \n        function generatePluginArray() {\n            const arr = fakeData.plugins\n                .map(obj => getSubset(['name', 'filename', 'description'], obj))\n                .map(obj => {\n                    const mimes = fakeData.mimeTypes.filter(\n                        m => m.__pluginName === obj.name\n                    )\n                    // Add mimetypes\n                    mimes.forEach((mime, index) => {\n                        navigator.mimeTypes[mime.type].enabledPlugin = obj\n                        obj[mime.type] = navigator.mimeTypes[mime.type]\n                        obj[index] = navigator.mimeTypes[mime.type]\n                    })\n                    obj.length = mimes.length\n                    return obj\n                })\n                .map(obj => {\n                    // Mock functions\n                    obj.namedItem = fakeData.fns.namedItem('Plugin')\n                    obj.item = fakeData.fns.item('Plugin')\n                    return obj\n                })\n                .map(obj => Object.setPrototypeOf(obj, Plugin.prototype))\n            arr.forEach(obj => {\n                arr[obj.name] = obj\n            })\n    \n            // Mock functions\n            arr.namedItem = fakeData.fns.namedItem('PluginArray')\n            arr.item = fakeData.fns.item('PluginArray')\n            arr.refresh = fakeData.fns.refresh('PluginArray')\n    \n            return Object.setPrototypeOf(arr, PluginArray.prototype)\n        }\n    \n        const pluginArray = generatePluginArray()\n        Object.defineProperty(navigator, 'plugins', {\n            get: () => pluginArray\n        })\n    \n        // Make mockedFns toString() representation resemble a native function\n        makeFnsNative(mockedFns)\n    }\n    try {\n        const isPluginArray = navigator.plugins instanceof PluginArray\n        const hasPlugins = isPluginArray && navigator.plugins.length > 0\n        if (isPluginArray && hasPlugins) {\n            // return // nothing to do here\n        } else {\n            mockPluginsAndMimeTypes()\n        }\n    } catch (err) {\n        console.error(err)\n    }\n    ")];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
exports.navigatorPlugins = navigatorPlugins;
